set fileformats=unix,mac,dos
set ttyfast
set ttimeout
set ttimeoutlen=10  " This must be a low value for <esc>-key not to be confused with an <a-â€¦> mapping
set mouse=a
if has('nvim')
  language en_US.UTF-8
  " !    - Save and restore all-caps global variables
  " '200 - Marks will be remembered for the last 200 files edited (also the number of `v:oldfiles` stored)
  " <50  - Contents of registers (up to 50 lines each) will be remembered
  " s10  - Items with contents occupying more then 10 KiB are skipped
  " h    - Disable the effect of 'hlsearch' when loading the shada file
  set shada=!,'200,<50,s10,h 
else
  set viminfo=!,'200,<50,s10,h
  set viminfofile=~/.viminfo
  " See :set termcap, :h t_ku, :h :set-termcap, and http://vim.wikia.com/wiki/Mapping_fast_keycodes_in_terminal_Vim
  set <a-h>=h
  set <a-j>=j
  set <a-k>=k
  set <a-l>=l
  if $TERM =~# '^\%(tmux\|screen\)'
    set ttymouse=xterm2
    " Make bracketed paste mode work inside tmux
    let &t_BE = "\033[?2004h"
    let &t_BD = "\033[?2004l"
    let &t_PS = "\033[200~"
    let &t_PE = "\033[201~"
  endif
endif
if exists('+termguicolors')
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
  set termguicolors
endif
" Show block cursor in Normal mode and line cursor in Insert mode
let &t_ti.="\<Esc>[2 q"
let &t_SI.="\<Esc>[6 q"
let &t_SR.="\<Esc>[4 q"
let &t_EI.="\<Esc>[2 q"
let &t_te.="\<Esc>[0 q"

syntax enable
filetype plugin indent on
set hidden
set confirm
set noswapfile nobackup
set undofile
set undodir=~/.vim/undo
set backspace=indent,eol,start
set nojoinspaces
set splitright
set splitbelow
set formatoptions+=1j
set autoindent
set shiftround
set smarttab
set expandtab
set wrap
set tabstop=2 shiftwidth=2 softtabstop=2

set hlsearch
set incsearch
set ignorecase
set infercase
set smartcase
set keywordprg=:help
set completeopt=menu
set complete=.
set complete-=t
set wildmenu
set wildignorecase
set wildignore+=build/*,*/node_modules/*

set scrolloff=6
set sidescrolloff=5
set cursorline
set display=lastline
set nonumber
set nowrap
set shortmess+=IcmFS
set shortmess-=s
set noshowcmd
set listchars=tab:>\ ,trail:-
set nolist
set signcolumn=auto
set background=dark
if executable('rg')
  set grepprg=rg\ -i\ --vimgrep
else
  set grepprg=grep\ --line-number\ --with-filename\ --recursive\ -I\ $*\ /dev/null
endif
set grepformat=%f:%l:%c:%m

let g:LargeFile = 20*1024*1024 " 20MB
augroup vimrc
  autocmd!
  autocmd BufReadPre *
        \ let s = getfsize(expand('<afile>')) |
        \ if s > g:LargeFile || s == -2 |
        \   call my_buffer#large(expand('<afile>:p')) |
        \ endif

  " On opening a file, jump to the last known cursor position
  autocmd BufReadPost *
        \ if line("'\"") > 1 && line("'\"") <= line("$") && &ft !~# 'commit' |
        \   exe "normal! g`\"" |
        \ endif

  " Auto-create parent directories. But not for URIs (paths containing "://").
  au BufWritePre,FileWritePre *
        \ if @% !~# '\(://\)' |
        \   call mkdir(expand('<afile>:p:h'), 'p') |
        \ endif

  autocmd BufEnter *.txt
        \ if &buftype == 'help' |
        \   nnoremap <buffer> q :q<cr> |
        \   nnoremap <buffer> T <c-]> |
        \ endif

  autocmd BufEnter man:///* wincmd L

  " Disable automatic comment insertion
  autocmd FileType * setlocal formatoptions-=cro

  autocmd WinEnter,FocusGained * set cursorline
  autocmd WinLeave,FocusLost   * set nocursorline

  if exists('##TerminalWinOpen')
    autocmd TerminalWinOpen * setlocal statusline=%f
  elseif exists('##TerminalOpen')
    autocmd TerminalOpen * setlocal statusline=%f
  elseif exists('##TermOpen')
    autocmd TermOpen * setlocal statusline=%f
  endif

  autocmd BufWritePost ~/.vim/vimrc source $MYVIMRC
  autocmd BufWritePost ~/.vim/lua/* luafile <afile>
  autocmd BufWritePost .tmux.conf call system('tmux source-file ' . expand('<afile>'))

  autocmd BufRead,BufNewFile *.metal set filetype=cpp
  autocmd BufRead,BufNewFile *.fnl   set filetype=clojure

  if has('nvim-0.5')
    autocmd TextYankPost * silent! lua require'vim.highlight'.on_yank('DiffAdd')
  endif

  fun! HlSearch()
    let s:pos = match(getline('.'), @/, col('.') - 1) + 1
    if s:pos != col('.')
      call StopHL()
    endif
  endf

  fun! StopHL()
    if !v:hlsearch || mode() !=# 'n'
      return
    endif
    silent call feedkeys("\<Plug>(StopHL)", 'm')
  endf

  autocmd CursorMoved * call HlSearch()
  autocmd InsertEnter * call StopHL()
augroup END

noremap <silent> <Plug>(StopHL) :<C-U>nohlsearch<cr>
noremap! <expr> <Plug>(StopHL) execute('nohlsearch')[-1]

"
" Status line
"
set laststatus=2
set noshowmode
if has('nvim-0.5')
  fun! MyStatusLineNeovim() abort
    return  MyStatusLine() . ' ' .
          \"%3*%{luaeval('
          \ (not vim.tbl_isempty(vim.lsp.buf_get_clients(0)) and (vim.b.diagnostics_count == nil or vim.b.diagnostics_count == 0))
          \ and [[âœ”]] or [[]]
          \')}%*" .
          \"%4*%{luaeval('
          \ (not vim.tbl_isempty(vim.lsp.buf_get_clients(0)) and (vim.b.diagnostics_count and vim.b.diagnostics_count > 0))
          \ and [[âœ˜]] or [[]]
          \')}%*"
  endf
  set statusline=%!MyStatusLineNeovim()
else
  set statusline=%!MyStatusLine()
endif

fun! MyStatusLine() abort
  return "%1*%{!&modifiable?'  X ':&ro?'  RO ':''}
        \%2*%{&modified?'  + ':''}
        \%* %f"
endf

"
" Tab line
"
set showtabline=1
set tabline=%!MyTabLine()

fun! MyTabLine()
  let s = ''
  for i in range(1, tabpagenr('$'))
    let s .= i == tabpagenr() ? '%#TabLineSel#' : '%#TabLine#'
    let s .= '%'.i.'T %{MyTabLabel('.i.')}'
  endfor
  return s.'%#TabLineFill#%T'
endf

fun! MyTabLabel(n)
  let buflist = tabpagebuflist(a:n)
  let modified = ''
  for b in buflist
    if getbufvar(b, '&modified')
      let modified = '+ '
      break
    endif
  endfor
  let name = fnamemodify(bufname(buflist[tabpagewinnr(a:n) - 1]), ':t:s/^$/[No Name]/')
  return modified.name.' '
endf

command! -range                  Diffusion <line1>,<line2> call my_fb#copy_diffusion_url()
command! -nargs=*
      \  -complete=file_in_path  Grep      cgetexpr my_fb#grep(<f-args>)
command! -nargs=1                PackInstall call <sid>packInstall(<q-args>)

fun! s:packInstall(url)
  let url = a:url
  if url =~ '/$'
    let url = url[:-2]
  endif
  if url !~ '.git$'
    let url .= '.git'
  endif
  let repo = substitute(url, '^.*/\([^/]\+\)/\?\.git$', '\1', '')
  " sanity check
  if strlen(repo) == strlen(url)
    echomsg 'regex failed'
    return
  endif
  " FIXME: git expands the tilde
  let cmd = printf('git submodule add --depth 1 --name "%s" -- %s ~/.vim/pack/third-party/start/%s', repo, shellescape(url), repo)
  execute '!'.cmd
endf

let mapleader = "\<space>"
let maplocalleader = ','

noremap j gj
noremap k gk
nnoremap <c-e> <c-e><c-e>
nnoremap <c-y> <c-y><c-y>
vnoremap < <gv
vnoremap > >gv
nnoremap s "_s
nnoremap Z zz5<c-e>
nnoremap * *zz
nnoremap # #zz
nnoremap p pmx=']`x
nnoremap P Pmx=']`x

nnoremap ; :
xnoremap ; :
nnoremap : ;
xnoremap : ;
nnoremap ' `
xnoremap ' `
nnoremap ` '
xnoremap ` '

nnoremap Q @q
noremap Y y$
noremap H ^
noremap L $
noremap <silent> ( :<c-u>keepjumps normal! H<cr>
noremap <silent> ) :<c-u>keepjumps normal! L<cr>
" noremap <silent> <tab> :<c-u>keepjumps normal! %<cr>
nnoremap <c-p> <c-i>
nnoremap <home> gg
nnoremap <end> G
nnoremap <leader>= H=L``

nnoremap <silent> G :<c-u>keepjumps normal! G<cr>
nnoremap <silent> M :<c-u>keepjumps normal! M<cr>
nnoremap <silent> { :<c-u>keepjumps normal! {<cr>
nnoremap <silent> } :<c-u>keepjumps normal! }<cr>
nnoremap <silent> n :<c-u>keepjumps normal! nzzzv<cr>
nnoremap <silent> N :<c-u>keepjumps normal! Nzzzv<cr>

map  Â¬ <a-l>
map  Ë™ <a-h>
map  âˆ† <a-j>
map  Ëš <a-k>
map! Â¬ <a-l>
map! Ë™ <a-h>
map! âˆ† <a-j>
map! Ëš <a-k>

noremap! <a-h> <left>
noremap! <a-l> <right>
noremap! <a-j> <c-left>
noremap! <a-k> <c-right>

nnoremap <c-l> <c-w>l
nnoremap <c-h> <c-w>h
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k

nnoremap <a-l> <c-w>L
nnoremap <a-h> <c-w>H
nnoremap <a-j> <c-w>J
nnoremap <a-k> <c-w>K

nnoremap <silent> ]b :<c-u>bnext<cr>
nnoremap <silent> [b :<c-u>bprev<cr>
nnoremap <silent> [t :<c-u>tabprev<cr>
nnoremap <silent> ]t :<c-u>tabnext<cr>
nnoremap <silent> ]n /\v^[<\|=>]{7}<cr>
nnoremap <silent> [n ?\v^[<\|=>]{7}<cr>
vnoremap <silent> ]n /\v^[<\|=>]{7}<cr>
vnoremap <silent> [n ?\v^[<\|=>]{7}<cr>

nmap [e <Plug>move_line_up
nmap ]e <Plug>move_line_down

if has('nvim-0.5')
  nmap [a <cmd>lua require'my.argument'.jump_prev()<cr>
  nmap ]a <cmd>lua require'my.argument'.jump_next()<cr>
else
  nmap [a <Plug>jump_arg_prev
  nmap ]a <Plug>jump_arg_next
endif

nnoremap <silent> ]q :<c-u><c-r>=v:count1<cr>cnext<cr>zz
nnoremap <silent> [q :<c-u><c-r>=v:count1<cr>cprevious<cr>zz
nnoremap <silent> ]Q :<c-u>cnfile<cr>zz
nnoremap <silent> [Q :<c-u>cpfile<cr>zz
nnoremap <silent> ]l :<c-u><c-r>=v:count1<cr>lnext<cr>zz
nnoremap <silent> [l :<c-u><c-r>=v:count1<cr>lprevious<cr>zz
nnoremap <silent> ]L :<c-u>lnfile<cr>zz
nnoremap <silent> [L :<c-u>lpfile<cr>zz

if has('nvim-0.5')
  nnoremap <silent> <leader>o <cmd>lua require'my.isearch'.search_oldfiles()<cr>
  nnoremap <silent> <leader>b <cmd>lua require'my.isearch'.search_buffers()<cr>
  nnoremap <silent> <leader>f <cmd>lua require'my.isearch'.search_files()<cr>
else
  nnoremap <silent> <leader>o :<c-u>call my_find#oldfiles()<cr>
  nnoremap <silent> <leader>b :<c-u>call my_find#buffer()<cr>
  nnoremap <silent> <leader>f :<c-u>call my_find#files()<cr>
endif

nnoremap <silent> <leader>d :<c-u>BD<cr>
nnoremap <silent> <leader>D :<c-u>bd<cr>
nnoremap <silent> <leader>q :<c-u>b#<cr>

nnoremap <silent> <leader>gd :<c-u>HGdiff<cr>
nnoremap <silent> <leader>gl :<c-u>call my_find#hg_commit()<cr>

nnoremap <silent> <expr> <leader>l (&hls && v:hlsearch ? ':nohls' : ':set hls')."\n"

nnoremap <leader>a :<c-u>Grep<space>
vnoremap <leader>a "sy:Grep <c-r>s

nnoremap <silent> <leader>ev :<c-u>edit ~/.vim/vimrc<cr>
nnoremap <silent> <leader>ec :<c-u>edit ~/.vim/pack/mine/opt/gruvburn/gruvburn.colortemplate<cr>
nnoremap <silent> <leader>et :<c-u>edit ~/notes/todo.taskpaper<bar>set bufhidden=wipe<cr>

cnoremap <c-p> <up>
cnoremap <c-n> <down>
cnoremap <c-j> <c-g>
cnoremap <c-k> <c-t>
cnoremap <c-o> <c-r>=expand("%:t:r")<cr>

nnoremap <silent> cd  :<c-u>cd %:h \| pwd<cr>
nnoremap <leader>s :%s/\<<c-r><c-w>\>/
nnoremap <leader>w :<c-u>w !sudo tee % >/dev/null<cr>
noremap  <silent> <leader>y y:<c-u>call my_fb#yank(@0)<cr>
nnoremap <silent> <leader>t :<c-u>tabedit<cr>
nnoremap gy :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>
" TODO: why doesn't zv work?
vnoremap * "ay/<c-r>a<cr>
vnoremap # "ay?<c-r>a<cr>

nnoremap g= ms'[=']`s

cnoreabbrev <expr> man getcmdtype() == ":" && getcmdline() == 'man' ? 'Man' : 'man'
cabbrev ~? ~/

" Disabled Vim plugins
let g:loaded_getscriptPlugin = 1
let g:loaded_gzip = 1
let g:loaded_logiPat = 1
let g:loaded_rrhelper = 1
let g:loaded_tarPlugin = 1
let g:loaded_vimballPlugin = 1
let g:loaded_zipPlugin = 1
let g:loaded_netrwPlugin = 1
let g:loaded_matchit = 1
let g:did_install_default_menus = 1 " $VIMRUNTIME/menu.vim

" vim-prettier
" packadd vim-prettier
let g:prettier#autoformat = 1

" vim-flow
let g:flow#enable = 0
let g:flow#timeout = 8
let g:flow#errjmp = 0

" vim-reasonml
let g:merlin_disable_default_keybindings = 1
let g:merlin_split_method = "never"

" vim-colortemplate
packadd vim-colortemplate
let g:colortemplate_no_mappings = 1
let g:colortemplate_toolbar = 0
autocmd vimrc BufWritePost *.colortemplate Colortemplate!
autocmd vimrc BufEnter *.colortemplate nnoremap <silent> <buffer> ga :<c-u>call colortemplate#getinfo(v:count1)<cr>
command! -nargs=0 Colortest runtime syntax/hitest.vim

" vim-qf
nmap <c-n> <Plug>(qf_qf_toggle)
let g:qf_auto_quit = 0
let g:qf_auto_resize = 0
let g:qf_mapping_ack_style = 1

" vim-dirvish
let g:dirvish_mode = ':sort ,^.*/,'
autocmd vimrc VimEnter *
      \ let has_stdin = &modified |
      \ if !argc() && !has_stdin |
      \   silent! Dirvish |
      \ endif

" vim-bufkill
let g:BufKillCreateMappings = 0

" vim-linediff
let g:linediff_buffer_type = 'scratch'
xnoremap <expr> D (mode() ==# "V" ? ':Linediff<cr>' : 'D')

" vim-matchup
let g:matchup_surround_enabled = 1
let g:matchup_matchparen_enabled = 1
let g:matchup_transmute_enabled = 1
let g:matchup_matchparen_offscreen = {}
let g:matchup_matchparen_enabled = 0 " disable highlighting
map <tab> <plug>(matchup-%)
for v in ['g', ']', '[', 'z', 'a', 'i']
  execute 'omap '.v.'m <plug>(matchup-'.v.'%)'
endfor
for v in ['g', ']', '[', 'z']
  execute 'nmap '.v.'m <plug>(matchup-'.v.'%)'
  execute 'vmap '.v.'m <plug>(matchup-'.v.'%)'
endfor
for v in ['ds', 'cs']
  execute 'nmap '.v.'m <plug>(matchup-'.v.'%)'
endfor

function! IsCommentaryOpFunc()
  return &operatorfunc ==? matchstr(maparg('<Plug>Commentary', 'n'),
        \ '\c<SNR>\w\+\ze()\|set op\%(erator\)\?func=\zs.\{-\}\ze<cr>')
endfunction
let g:matchup_text_obj_linewise_operators = ['d', 'y', 'c', 'v', 'g@,IsCommentaryOpFunc()']

" vim-quickhl
nmap <2-leftmouse> <Plug>(quickhl-manual-this)
nmap <rightmouse> <Plug>(quickhl-manual-reset)
let g:quickhl_manual_colors = [
      \ "ctermfg=16  ctermbg=153 guibg=#0a7383",
      \ "ctermfg=7   ctermbg=1   guibg=#a07040",
      \ "ctermfg=7   ctermbg=2   guibg=#4070a0",
      \ "ctermfg=7   ctermbg=3   guibg=#40a070",
      \ ]

" rust.vim
" let g:rustfmt_autosave = 1

"
" Neovim nightly
"
if has('nvim-0.5')
  command! CheckLsp lua print(vim.inspect(vim.lsp.buf_get_clients()))

  function! s:restartLsp()
    lua vim.lsp.stop_client(vim.lsp.get_active_clients())
    doautocmd BufReadPost
  endfunction
  command! RestartLsp call <sid>restartLsp()

  " nvim-lsp
  packadd nvim-lsp

  " for name in ['LspDiagnosticsErrorSign', 
  "   call sign_define(name, {'text' : 'â€ºâ€º'})
  " endfor

  luafile ~/.vim/lua/my/lsp.lua

  " text-object: comment
  xnoremap <expr>   ac luaeval("require'my.comment'.set_marks()")
  onoremap <silent> ac :normal Vac<CR>
  xnoremap <expr>   ic luaeval("require'my.comment'.set_marks()")
  onoremap <silent> ic :normal Vic<CR>
endif

packadd! gruvburn
silent! colorscheme gruvburn

"
" adapted from justinmk's init.vim
"
xnoremap <expr> I (mode()=~#'[vV]'?'<C-v>^o^I':'I')
xnoremap <expr> A (mode()=~#'[vV]'?'<C-v>0o$A':'A')

" word-wise i_CTRL-Y
inoremap <expr> <c-y> pumvisible() ? "\<c-y>" : matchstr(getline(line('.')-1), '\%' . virtcol('.') . 'v\%(\k\+\\|.\)')

nnoremap gqax :%!tidy -q -i -xml -utf8<cr>
nnoremap gqah :%!tidy -q -i -ashtml -utf8<cr>
nnoremap gqaj :%!python -m json.tool<cr>
nnoremap gwaj :call append('$', json_encode(eval(join(getline(1,'$')))))<cr>'[k"_dVgg:%!python -m json.tool<cr>

nnoremap / ms/

nnoremap g> :set nomore<bar>echo repeat("\n",&cmdheight)<bar>40messages<bar>set more<CR>
nnoremap gj i<c-j><esc>k$

if executable('lynx')
  command! -nargs=1 Web       vnew|call termopen('lynx -use_mouse '.shellescape(<q-args>))
  command! -nargs=1 Websearch vnew|call termopen('lynx -use_mouse '.shellescape('https://duckduckgo.com/?q='.substitute(<q-args>,'#','%23','g')))
endif

" text-object: inner line (leading whitespace trimmed)
function! s:line_inner_movement(count) abort
  if empty(getline('.'))
    return "\<Esc>"
  endif
  let [lopen, lclose] = [line('.'), line('.')]
  let copen = match(getline('.'), '\S') + 1
  let cclose = col('$') - 1
  call setpos("'[", [0, lopen, copen, 0])
  call setpos("']", [0, lclose, cclose, 0])
  return "`[o`]"
endfunction
xnoremap <expr>   il <SID>line_inner_movement(v:count1)
onoremap <silent> il :normal vil<CR>

" text-object: outer line
function! s:line_outer_movement(count) abort
  if empty(getline('.'))
    return "\<Esc>"
  endif
  let [lopen, copen, lclose, cclose] = [line('.'), 1, line('.'), col('$')]
  call setpos("'[", [0, lopen, copen, 0])
  call setpos("']", [0, lclose, cclose, 0])
  return "`[o`]"
endfunction
xnoremap <expr>   al <SID>line_outer_movement(v:count1)
onoremap <silent> al :normal val<CR>
