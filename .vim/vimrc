if has('nvim')
    set rtp^=~/.vim
    set rtp+=~/.vim/after
    let &packpath = &runtimepath
    " !    - Save and restore all-caps global variables
    " '200 - Marks will be remembered for the last 200 files edited (also the number of `v:oldfiles` stored)
    " <50  - Contents of registers (up to 50 lines each) will be remembered
    " s10  - Items with contents occupying more then 10 KiB are skipped
    " h    - Disable the effect of 'hlsearch' when loading the shada file
    set shada=!,'200,<50,s10,h 
else
    set viminfo=!,'200,<50,s10,h
    set viminfofile=~/.viminfo
    " See :set termcap, :h t_ku, :h :set-termcap, and http://vim.wikia.com/wiki/Mapping_fast_keycodes_in_terminal_Vim
    set <a-h>=h
    set <a-j>=j
    set <a-k>=k
    set <a-l>=l
    if $TERM =~# '^\%(tmux\|screen\)'
        set ttymouse=xterm2
        " Make bracketed paste mode work inside tmux
        let &t_BE = "\033[?2004h"
        let &t_BD = "\033[?2004l"
        let &t_PS = "\033[200~"
        let &t_PE = "\033[201~"
    endif
endif
set fileformats=unix,mac,dos
set ttyfast
set ttimeout
set ttimeoutlen=10  " This must be a low value for <esc>-key not to be confused with an <a-â€¦> mapping
set mouse=a
set lazyredraw
set synmaxcol=250
if exists('+termguicolors')
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
    set termguicolors
endif
" Show block cursor in Normal mode and line cursor in Insert mode
let &t_ti.="\<Esc>[2 q"
let &t_SI.="\<Esc>[6 q"
let &t_SR.="\<Esc>[4 q"
let &t_EI.="\<Esc>[2 q"
let &t_te.="\<Esc>[0 q"

syntax enable
filetype plugin indent on
set hidden
set confirm
set noswapfile nobackup
set undofile
set undodir=~/.vim/undo
set backspace=indent,eol,start
set nojoinspaces
set splitright
set splitbelow
set formatoptions+=1j
set autoindent
set shiftround
set smarttab
set expandtab
set shiftwidth=4
set tabstop=4
set softtabstop=-1
if has('nvim')
    set display=msgsep
    set inccommand=nosplit
else
    set display=lastline
endif
set hlsearch
set incsearch
set ignorecase
set infercase
set smartcase
set keywordprg=:help
set completeopt=menu
set complete=.,i,w,b
set wildmenu
set wildignorecase
set wildignore&vim
set wildignore+=build/*,*/node_modules/*

set foldtext=v:folddashes.getline(v:foldstart)
set foldmethod=marker
set foldlevelstart=0
set foldopen-=block

set nomodeline
set modelines=0

set scrolloff=2
set sidescrolloff=2
set virtualedit=block
set nowrap
set shortmess&vim
set shortmess+=aTWIcFS
set shortmess-=s
set noshowcmd
set listchars=tab:â€º\ ,trail:-,nbsp:âˆ…
set fillchars=fold:\ 
set signcolumn=no
set background=dark
if executable('rg')
    set grepprg=rg\ -i\ --vimgrep
else
    set grepprg=grep\ --line-number\ --with-filename\ --recursive\ -I\ $*\ /dev/null
endif
set grepformat=%f:%l:%c:%m

if !exists('s:SID')
    fu s:SID() abort
        return str2nr(matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$'))
    endfu
    let s:SID = printf('<SNR>%d_', s:SID())
    delfu s:SID
endif

let g:LargeFile = 20*1024*1024 " 20MB
augroup vimrc
    autocmd!
    autocmd BufReadPre *
                \ let s = getfsize(expand('<afile>')) |
                \ if s > g:LargeFile || s == -2 |
                \   call <sid>large_buffer(expand('<afile>:p')) |
                \ endif

    fu s:large_buffer(name)
        let b:my_large_file = 1
        syntax clear
        set eventignore=all
        let &backupskip .= ',' . a:name
        setlocal foldmethod=manual nofoldenable noswapfile noundofile
        aug large_buffer | au!
            au BufWinEnter <buffer> call <sid>restore_eventignore()
        aug END
    endfu

    fu s:restore_eventignore()
        set eventignore&vim
        au! large_buffer
        aug! large_buffer
    endfu

    autocmd BufReadPost *
                \ if line("'\"") > 1 && line("'\"") <= line("$") && &ft !~# 'commit' |
                \   exe "normal! g`\"" |
                \ endif

    " Auto-create parent directories. But not for URIs (paths containing "://").
    au BufWritePre,FileWritePre *
                \ if @% !~# '\(://\)' |
                \   call mkdir(expand('<afile>:p:h'), 'p') |
                \ endif

    autocmd BufEnter *.txt
                \ if &buftype == 'help' |
                \   setlocal scrolloff=0 |
                \   nno <buffer> q :q<cr> |
                \   nno <buffer> T <c-]> |
                \ endif

    " Disable automatic comment insertion
    autocmd FileType * setlocal formatoptions-=cro

    if exists('##TerminalWinOpen')
        autocmd TerminalWinOpen * setlocal statusline=%f
    elseif exists('##TerminalOpen')
        autocmd TerminalOpen * setlocal statusline=%f
    elseif exists('##TermOpen')
        autocmd TermOpen * setlocal statusline=%f
    endif

    " Warning: any BufWritePost autocmd after this will not get run when
    " writing vimrc, because sourcing the vimrc will clear the augroup
    autocmd BufWritePost ~/.vim/vimrc source $MYVIMRC
    autocmd BufWritePost ~/.vim/lua/* luafile <afile>
    autocmd BufWritePost *tmux.conf   call system('tmux source-file '.expand('<afile>'))

    autocmd BufRead,BufNewFile *.metal    set filetype=glsl
    autocmd BufRead,BufNewFile *.fnl      set filetype=clojure
    autocmd BufRead,BufNewFile *tmux.conf set filetype=tmux

    if has('nvim-0.5')
        autocmd TextYankPost * silent! lua require'vim.highlight'.on_yank('DiffAdd')
    endif

    fu HlSearch()
        " bail out if cursor is at top/bottom of window
        let wininfo = getwininfo(win_getid())[0]
        let lnum = getcurpos()[1]
        if lnum == wininfo.botline - &scrolloff || lnum == wininfo.topline + &scrolloff
            return
        endif

        let pos = match(getline('.'), @/, col('.') - 1) + 1
        if pos != col('.')
            call StopHL()
        endif
    endfu

    fu StopHL()
        if !v:hlsearch || mode() !=# 'n'
            return
        endif
        silent call feedkeys("\<Plug>(StopHL)", 'm')
    endfu

    autocmd CursorMoved * call HlSearch()
    autocmd InsertEnter * call StopHL()
augroup END

no <silent> <Plug>(StopHL) :<C-U>nohlsearch<cr>
no! <expr> <Plug>(StopHL) execute('nohlsearch')[-1]

"
" Status line
" TODO: why does buf_diagnostics_count() sometimes return nil??
"
set laststatus=2
set noshowmode
if has('nvim-0.5')
    lua <<
    _G.lsp_statusline_no_errors = function ()
        if vim.tbl_isempty(vim.lsp.buf_get_clients(0)) then
            return ''
        end
        local errors = vim.lsp.util.buf_diagnostics_count('Error') or 0
        local warnings = vim.lsp.util.buf_diagnostics_count('Warning') or 0
        if errors == 0 and warnings == 0 then
            return 'âœ”'
        end
        return ''
    end
    _G.lsp_statusline_has_errors = function ()
        if vim.tbl_isempty(vim.lsp.buf_get_clients(0)) then
            return ''
        end
        local errors = vim.lsp.util.buf_diagnostics_count('Error') or 0
        local warnings = vim.lsp.util.buf_diagnostics_count('Warning') or 0
        if errors > 0 or warnings > 0 then
            return 'âœ˜'
        end
        return ''
    end
.
    fu MyStatusLineNeovim() abort
        return  MyStatusLine() . ' ' .
                    \"%3*%{v:lua.lsp_statusline_no_errors()}%*" .
                    \"%4*%{v:lua.lsp_statusline_has_errors()}%*"
    endfu
    set statusline=%!MyStatusLineNeovim()
else
    set statusline=%!MyStatusLine()
endif

fu MyStatusLine() abort
    return "%1*%{!&modifiable?'  X ':&ro?'  RO ':''}
                \%2*%{&modified?'  + ':''}
                \%* %f"
endfu

"
" Tab line
"
set showtabline=1
set tabline=%!MyTabLine()

fu MyTabLine()
    let s = ''
    for i in range(1, tabpagenr('$'))
        let s .= i == tabpagenr() ? '%#TabLineSel#' : '%#TabLine#'
        let s .= '%'.i.'T %{MyTabLabel('.i.')}'
    endfor
    return s.'%#TabLineFill#%T'
endfu

fu MyTabLabel(n)
    let buflist = tabpagebuflist(a:n)
    let modified = ''
    for b in buflist
        if getbufvar(b, '&modified')
            let modified = '+ '
            break
        endif
    endfor
    let name = fnamemodify(bufname(buflist[tabpagewinnr(a:n) - 1]), ':t:s/^$/[No Name]/')
    return modified.name.' '
endfu

com! -range Diffusion <line1>,<line2> call my_fb#copy_diffusion_url()

com! -nargs=* -complete=file_in_path Grep call <sid>grep(<f-args>)

fu s:grep(...) abort
    if a:0 == 0
        return
    endif
    let cmd = 'rg -i --vimgrep '.shellescape(a:1)
    if a:0 > 1
        let cmd .=  ' '.shellescape(expandcmd(a:2))
    endif
    " could also populate the quickfix list, and hide it?
    execute "lua require'my.isearch'.grep([[".cmd."]])"
endfu

com! -nargs=1 PackInstall call <sid>packInstall(<q-args>)

fu s:packInstall(url)
    let url = a:url
    if url =~ '/$'
        let url = url[:-2]
    endif
    if url !~ '.git$'
        let url .= '.git'
    endif
    let repo = substitute(url, '^.*/\([^/]\+\)/\?\.git$', '\1', '')
    " sanity check
    if strlen(repo) == strlen(url)
        echomsg 'regex failed'
        return
    endif
    " FIXME: git expands the tilde
    let cmd = printf('git submodule add --depth 1 --name "%s" -- %s ~/.vim/pack/third-party/start/%s', repo, shellescape(url), repo)
    execute '!(cd ~ && '.cmd.')'
endfu

let mapleader = "\<s-f5>"
let maplocalleader = "\<s-f6>"

no j gj
no k gk
nno <c-e> <c-e><c-e>
nno <c-y> <c-y><c-y>
xno < <gv
xno > >gv
nno s "_s
nno Z zzzH
xno Z zzzH
nno <expr> p getreg('"') =~ "\n" ? "pmx=']`x" : "p"
nno <expr> P getreg('"') =~ "\n" ? "Pmx=']`x" : "P"

nno ; :
xno ; :
nno : ;
xno : ;

nno ' `

nno Q @q
no Y y$
no H ^
no L $
no <silent> ( :<c-u>keepjumps normal! H<cr>
no <silent> ) :<c-u>keepjumps normal! L<cr>
nno <c-p> <c-i>
nm <home> gg
nm <end> G
nno <pageup> <pageup>H
nno <pagedown> <pagedown>L

" TODO: how to keepjumps in visual mode without breaking selection
nno <silent> gg :<c-u>keepjumps normal! gg<cr>
nno <silent> G :<c-u>keepjumps normal! G<cr>
nno <silent> M :<c-u>keepjumps normal! M<cr>
nno <silent> { :<c-u>keepjumps normal! {<cr>
nno <silent> } :<c-u>keepjumps normal! }<cr>
nno <silent> n :<c-u>keepjumps normal! nzzzv<cr>
nno <silent> N :<c-u>keepjumps normal! Nzzzv<cr>

no! <a-h> <left>
no! <a-l> <right>
no! <a-j> <c-left>
no! <a-k> <c-right>

nno <c-l> <c-w>l
nno <c-h> <c-w>h
nno <c-j> <c-w>j
nno <c-k> <c-w>k

nno <a-l> <c-w>L
nno <a-h> <c-w>H
nno <a-j> <c-w>J
nno <a-k> <c-w>K

nno <silent> ]b :<c-u>bnext<cr>
nno <silent> [b :<c-u>bprev<cr>
nno <silent> [t :<c-u>tabprev<cr>
nno <silent> ]t :<c-u>tabnext<cr>
nno <silent> ]n /\v^[<\|=>]{7}<cr>
nno <silent> [n ?\v^[<\|=>]{7}<cr>
xno <silent> ]n /\v^[<\|=>]{7}<cr>
xno <silent> [n ?\v^[<\|=>]{7}<cr>

nno <expr> [e <sid>move_line_setup('up')
nno <expr> ]e <sid>move_line_setup('down')

fu s:move_line_setup(dir, asldf, sadf) abort
    let s:indent_with_shiftround = {'dir': a:dir}
    let &opfunc = s:SID .. 'move_line'
    return 'g@l'
endfu

" FIXME: v:count1 doesn't work if indenting
fu s:move_line(_) abort
    let dir = s:indent_with_shiftround.dir
    norm! m`
    exe 'move' (dir is# 'up' ? '--' : '+') .. v:count1
    norm! =``
endfu

nno <silent> [a :<c-u>call <SID>jump_arg(0)<cr>
nno <silent> ]a :<c-u>call <SID>jump_arg(1)<cr>

fu s:jump_arg(forward)
    let flags = (a:forward ? '' : 'b').'W'
    call searchpair('[({[]', ',', '[]})]', flags, 's:isCursorInStringOrComment()')
endfu

fu s:isCursorInStringOrComment()
    let syn = synIDattr(synID(line('.'), col('.'), 0), 'name')
    return syn =~? 'string' || syn =~? 'comment'
endfu

nno <silent> ]q :<c-u><c-r>=v:count1<cr>cnext<cr>zz
nno <silent> [q :<c-u><c-r>=v:count1<cr>cprevious<cr>zz
nno <silent> ]Q :<c-u>cnfile<cr>zz
nno <silent> [Q :<c-u>cpfile<cr>zz
nno <silent> ]l :<c-u><c-r>=v:count1<cr>lnext<cr>zz
nno <silent> [l :<c-u><c-r>=v:count1<cr>lprevious<cr>zz
nno <silent> ]L :<c-u>lnfile<cr>zz
nno <silent> [L :<c-u>lpfile<cr>zz

if has('nvim-0.5')
    no <silent> <space>o <cmd>lua require'my.isearch'.search_oldfiles()<cr>
    no <silent> <space>b <cmd>lua require'my.isearch'.search_buffers()<cr>
    no <silent> <space>f <cmd>lua require'my.isearch'.search_files()<cr>
endif

no <silent> <space>d :<c-u>BD<cr>
no <silent> <space>D :<c-u>bd<cr>
no <silent> <space>q :<c-u>b#<cr>

no <silent> <space>gd :<c-u>Diffusion<cr>
no <silent> <space>gl :<c-u>call my_find#hg_commit()<cr>

no <silent> <expr> <space>l (&hls && v:hlsearch ? ':nohls' : ':set hls')."\n"

nno <space>a :<c-u>Grep<space>
xno <space>a "sy:Grep <c-r>s

no <silent> <space>ev :<c-u>edit ~/.vim/vimrc<cr>
no <silent> <space>el :<c-u>edit ~/.vim/lua/my<cr>
no <silent> <space>ez :<c-u>edit ~/.zshrc<cr>
no <silent> <space>ec :<c-u>edit ~/.vim/pack/mine/opt/gruvburn/gruvburn.colortemplate<cr>
no <silent> <space>en :<c-u>edit ~/notes/todo.taskpaper<bar>set bufhidden=wipe<cr>
no <silent> <space>et :<c-u>edit ~/.config/tmux/tmux.conf<cr>
no <silent> <space>ea :<c-u>edit ~/.config/alacritty/alacritty.yml<cr>

cno <c-p> <up>
cno <c-n> <down>
cno <c-j> <c-g>
cno <c-k> <c-t>
cno <c-o> <c-r>=expand("%:t:r")<cr>

nno <silent> cd :<c-u>cd %:h \| pwd<cr>
" TODO: any way to get inccommand to update?
nno <space>s :%s///<left>
nno <space>w :<c-u>w !sudo tee % >/dev/null<cr>
nno <silent> <space>t :<c-u>tabedit<cr>
no  <silent> <space>y y:<c-u>call my_fb#yank(@0)<cr>

nno             U :<c-u>let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
nno <2-leftmouse> :<c-u>let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
nno g= ms'[=']`s
nno <space>= H=L``
nno 'e 2g;zz
nno g<c-v> `[v`]
nno gV     '[V']
xno * "ayms/<c-r>a<cr>zzzv
xno # "ayms?<c-r>a<cr>zzzv
nno * ms*zzzv
nno # ms#zzzv
nno c* *``/<up><cr>``cgn
nno c# #``/<up><cr>``cgN

nno gy :<c-u>call <sid>show_syntax()<cr>
fu s:show_syntax()
    echo printf("hi<%s> trans<%s> lo<%s>",
                \ synIDattr(synID(line("."), col("."),1), "name"),
                \ synIDattr(synID(line("."), col("."),0), "name"),
                \ synIDattr(synIDtrans(synID(line("."), col("."), 1)), "name"))
endfu

cnorea <expr> man getcmdtype() == ":" && getcmdline() == 'man' ? 'Man' : 'man'
" TODO: immediately expand
ca ~? ~/

" Disabled Vim plugins
let g:loaded_getscriptPlugin = 1
let g:loaded_gzip = 1
let g:loaded_logiPat = 1
let g:loaded_rrhelper = 1
let g:loaded_tarPlugin = 1
let g:loaded_vimballPlugin = 1
let g:loaded_vimball = 1
let g:loaded_zipPlugin = 1
let g:loaded_netrwPlugin = 1
let g:loaded_matchit = 1
let g:did_install_default_menus = 1 " $VIMRUNTIME/menu.vim
if has('nvim')
    let g:loaded_python_provider = 0
    let g:loaded_perl_provider = 0
    let g:loaded_ruby_provider = 0
    let g:loaded_node_provider = 0
endif

" vim-prettier
" packadd vim-prettier
let g:prettier#autoformat = 1

" vim-flow
let g:flow#enable = 0
let g:flow#timeout = 8
let g:flow#errjmp = 0

" vim-reasonml
let g:merlin_disable_default_keybindings = 1
let g:merlin_split_method = "never"

" vim-colortemplate
packadd vim-colortemplate
let g:colortemplate_no_mappings = 1
let g:colortemplate_toolbar = 0
autocmd vimrc BufWritePost *.colortemplate set ei=FileType | Colortemplate! | set ei&vim | exe 'colo' g:colors_name
autocmd vimrc BufEnter *.colortemplate nno <silent> <buffer> ga :<c-u>call colortemplate#getinfo(v:count1)<cr>
com! -nargs=0 Colortest runtime syntax/hitest.vim

" vim-qf
nm <c-n> <Plug>(qf_qf_toggle)
let g:qf_auto_quit = 0
let g:qf_auto_resize = 0
let g:qf_mapping_ack_style = 1

" vim-dirvish
let g:dirvish_mode = ':sort ,^.*/,'
autocmd vimrc VimEnter *
            \ let has_stdin = &modified |
            \ if !argc() && !has_stdin |
            \   silent! Dirvish |
            \ endif

" vim-bufkill
let g:BufKillCreateMappings = 0

" vim-linediff
let g:linediff_buffer_type = 'scratch'
xno <expr> D (mode() ==# "V" ? ':Linediff<cr>' : 'D')

" vim-matchup
let g:matchup_surround_enabled = 1
let g:matchup_transmute_enabled = 1
let g:matchup_matchparen_offscreen = {}
let g:matchup_motion_keepjumps = 1
autocmd vimrc FileType * let b:matchup_matchparen_enabled = 0
map <tab> <plug>(matchup-%)
for v in ['g', ']', '[', 'z', 'a', 'i']
    execute 'omap '.v.'m <plug>(matchup-'.v.'%)'
endfor
for v in ['g', ']', '[', 'z']
    execute 'nmap '.v.'m <plug>(matchup-'.v.'%)'
    execute 'vmap '.v.'m <plug>(matchup-'.v.'%)'
endfor
for v in ['ds', 'cs']
    execute 'nmap '.v.'m <plug>(matchup-'.v.'%)'
endfor

fu IsCommentaryOpFunc()
    return &operatorfunc ==? matchstr(maparg('<Plug>Commentary', 'n'),
                \ '\c<SNR>\w\+\ze()\|set op\%(erator\)\?func=\zs.\{-\}\ze<cr>')
endfu
let g:matchup_text_obj_linewise_operators = ['d', 'y', 'c', 'v', 'g@,IsCommentaryOpFunc()']

" rust.vim
" let g:rustfmt_autosave = 1

"
" Neovim nightly
"
if has('nvim-0.5')
    com! CheckLsp lua print(vim.inspect(vim.lsp.buf_get_clients()))
    com! RestartLsp call <sid>restartLsp()

    fu s:restartLsp()
        lua vim.lsp.stop_client(vim.lsp.get_active_clients())
        edit
    endfu

    packadd nvim-lsp
    luafile ~/.vim/lua/my/lsp.lua
endif

packadd! gruvburn
silent! colorscheme gruvburn

"
" adapted from justinmk's init.vim
"
xno <expr> I (mode()=~#'[vV]'?'<C-v>^o^I':'I')
xno <expr> A (mode()=~#'[vV]'?'<C-v>0o$A':'A')

nno gqax :%!tidy -q -i -xml -utf8<cr>
nno gqah :%!tidy -q -i -ashtml -utf8<cr>
nno gqaj :%!python -m json.tool<cr>
nno gwaj :call append('$', json_encode(eval(join(getline(1,'$')))))<cr>'[k"_dVgg:%!python -m json.tool<cr>

nno / ms/

nno <silent> g> :set nomore<bar>echo repeat("\n",&cmdheight)<bar>40messages<bar>set more<CR>
nno gj i<c-j><esc>k$

"
" adapted from lacygoill's vimrc
"
nno <expr> <space>. <sid>repeat_last_edit_on_last_changed_text()

fu s:repeat_last_edit_on_last_changed_text() abort
    " put the last changed text inside the search register, so that we can refer
    " to it with the text-object `gn`
    let changed = getreg('"', 1, 1)
    if empty(changed) | return | endif
    call map(changed, {_,v -> escape(v, '\')})
    if len(changed) == 1
        let pat = changed[0]
    else
        " can't join with real newlines: they would be translated as NULs in the search register
        " we need to join with the *atom* `\n`
        let pat = changed->join('\n')
    endif
    call setreg('/', '\V'..pat, 'c')
    set hls
    return "cgn\<c-@>"
    "          â”œâ”€â”€â”€â”€â”˜
    "          â”” insert the previously inserted text and stop insert
endfu

xno <silent> in :<c-u>call <sid>textobj_number(v:false)<cr>
ono <silent> in :<c-u>call <sid>textobj_number(v:false)<cr>

" same thing, but includes possible whitespace after the number
xno <silent> an :<c-u>call <sid>textobj_number(v:true)<cr>
ono <silent> an :<c-u>call <sid>textobj_number(v:true)<cr>

fu s:textobj_number(around) abort
    let stopline = line('.')
    let pat = '\%('..s:get_patnum()..'\)'..(a:around ? '\s*' : '')
    " move cursor to end of number
    if !search(pat, 'ceW', stopline)
        return
    endif

    " start visual selection from end of number
    norm! v

    " select back to start of number
    call search(pat, 'bcW', stopline)
    " clear command-line when pressing `.` (e.g. `dan .`)
    echo
endfu

fu s:get_patnum() abort
    let sign = '[-+]\='
    let decimal = '\d\+\.\=\d*'
    let fraction = '\.\d\+'
    let exponent = '[eE]'..sign..'\d\+'
    let number = printf('%s\%%(%s\|%s\)\%%(%s\)\=', sign, decimal, fraction, exponent)

    let binary = '0b[01]\+'
    let hex = '0x\x\+'

    " the order matters; keep `number` at the end
    let pat = binary..'\|'..hex..'\|'..number
    return pat
endfu

" text-object: inner line (leading whitespace trimmed)
ono <silent> il :<c-u>norm! _vg_<cr>

" search only in visual selection
xno <silent> / :<c-u>call <sid>visual_slash()<cr>

fu s:visual_slash() abort
    if line("'<") == line("'>")
        call feedkeys('gv/', 'in')
    else
        " Do not reselect the visual selection with `gv`.{{{
        "
        " It could make move the end of the selection when you type some pattern
        " which matches inside.  That's not what we want.
        " We want to search  in the last visual selection as  it was defined; we
        " don't want to redefine it in the process.
        "}}}
        call feedkeys('/\%V', 'in')
    endif
endfu

" repeat last edit on all the visually selected lines with dot
xno <silent> . :norm! .<cr>

com! -bar DiffOrig echo s:diff_orig()

fu s:diff_orig() abort
    let cole_save = &l:conceallevel
    setl conceallevel=0

    let tempfile = tempname()..'/Original File'
    exe 'vnew '..tempfile
    setl buftype=nofile nobuflisted noswapfile nowrap

    sil 0r ++edit #
    keepj $d_
    setl nomodifiable readonly

    diffthis
    nno <buffer><expr><nowait><silent> q reg_recording() isnot# '' ? 'q' : ':<c-u>q<cr>'
    let &filetype = getbufvar('#', '&ft')

    let s:tmp_partial = function('s:diff_orig_restore_settings', [cole_save])
    augroup diff_orig_restore_settings
        au! * <buffer>
        au BufWipeOut <buffer>  call timer_start(0, s:tmp_partial)
    augroup END

    exe winnr('#')..'windo diffthis'
    return ''
endfu

fu s:diff_orig_restore_settings(conceallevel,_) abort
    exe 'setl conceallevel='..a:conceallevel
    diffoff!
    norm! zvzz
    aug! diff_orig_restore_settings
    unlet s:tmp_partial
endfu

" eVal
nno <silent> <space>v V:<c-u>call <sid>dump_result()<cr>
xno <silent> <space>v :<c-u>call <sid>dump_result()<cr>

fu s:dump_result() abort
    let [line_start, column_start] = getpos("'<")[1:2]
    let [line_end, column_end] = getpos("'>")[1:2]
    if line_start != line_end
        echohl ErrorMsg | echo "can't do multiline selection" | echohl None
        return
    endif
    let lines = getline(line_start, line_end)
    if empty(lines) | return | endif
    let line = lines[0][column_start-1:column_end-1]
    if empty(line) | return | endif
    if &filetype is# 'vim'
        let res = eval(line)
    elseif &filetype is# 'lua'
        " FIXME: null characters
        let res = luaeval('vim.inspect(' .. line .. ')')
    elseif &filetype =~# 'z\?sh'
        let res = system(line)
    elseif &filetype =~# 'javascript'
        " TODO
        return
    else
        return
    endif
    call setline('.', getline('.')[0:column_end] .. ' = ' .. trim(res))
endfu

ino <silent> <c-l> <c-r>=<sid>insert_log()<cr>

fu s:insert_log()
    if &filetype is# 'javascript'
        call feedkeys("console.log()\<left>")
        return ''
    elseif &filetype is# 'lua'
        call feedkeys("print(vim.inspect())\<left>\<left>")
        return ''
    elseif &filetype is# 'reason'
        return '[%debugger];'
    elseif &filetype is# 'vim'
        return 'echom '
    endif
endfu

autocmd vimrc BufReadPost * call s:fasd_update()
fu s:fasd_update() abort
  if empty(&buftype) || &filetype ==# 'dirvish'
    call jobstart(['fasd', '-A', expand('%:p')])
  endif
endfu

let vimrc_local = expand('<sfile>:p:h')..'/local.vim'
if filereadable(vimrc_local)
    execute 'source' vimrc_local
endif

" TODO: create visual mode mapping "D" that duplicates the selection, and comments one of them
